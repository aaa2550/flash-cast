import React, { useState, useEffect, useRef } from 'react';
import styled, { keyframes, css } from 'styled-components';
import { useRouter } from 'next/router';
import { theme } from '../styles/theme';
import { DouyinQRScanner } from '../components/DouyinQRScanner';
import { DouyinUserInfo } from '../services/api';
import { AuthGuard } from '../components/AuthGuard';
import {
  WorkflowStep,
  StepStatus,
  WorkflowStepInfo,
  WORKFLOW_STEPS,
  parseVideoContent,
  rewriteContent,
  synthesizeAudio,
  synthesizeVideo,
  publishVideo,
  PixelType,
  RewriteParams,
  SynthesizeAudioParams,
  SynthesizeVideoParams,
  PublishVideoParams
} from '../services/workflow';

// åŠ¨ç”»æ•ˆæœ
const flowAnimation = keyframes`
  0% { background-position: 0% 50%; }
  100% { background-position: 100% 50%; }
`;

const pulseGlow = keyframes`
  0%, 100% { box-shadow: 0 0 20px ${theme.colors.primary}; }
  50% { box-shadow: 0 0 40px ${theme.colors.primary}, 0 0 60px ${theme.colors.primary}; }
`;

// é¡µé¢å®¹å™¨
const PageContainer = styled.div`
  min-height: 100vh;
  background: ${theme.colors.bgDeep};
  color: ${theme.colors.text};
  position: relative;
  overflow: hidden;
`;

// ç½‘æ ¼èƒŒæ™¯
const GridBackground = styled.div`
  position: fixed;
  inset: 0;
  background-image: 
    linear-gradient(${theme.colors.border} 1px, transparent 1px),
    linear-gradient(to right, ${theme.colors.border} 1px, transparent 1px);
  background-size: 40px 40px;
  opacity: 0.1;
  pointer-events: none;
`;

// ä¸»å®¹å™¨
const Container = styled.div`
  max-width: 1400px;
  margin: 0 auto;
  padding: ${theme.spacing.lg} ${theme.spacing.xl};
  position: relative;
  z-index: 1;
  height: 100vh;
  display: flex;
  flex-direction: column;
`;

// æ ‡é¢˜
const Title = styled.h1`
  font-size: 2rem;
  color: ${theme.colors.primary};
  text-align: center;
  margin-bottom: ${theme.spacing.lg};
  text-shadow: ${theme.shadows.glow};
  letter-spacing: 2px;
`;

// Tabå¯¼èˆªå®¹å™¨
const TabNav = styled.div`
  display: flex;
  gap: ${theme.spacing.sm};
  margin-bottom: ${theme.spacing.md};
  overflow-x: auto;
  padding-bottom: ${theme.spacing.xs};
  flex-shrink: 0;
  
  &::-webkit-scrollbar {
    height: 4px;
  }
  
  &::-webkit-scrollbar-track {
    background: ${theme.colors.bgSlight};
    border-radius: 2px;
  }
  
  &::-webkit-scrollbar-thumb {
    background: ${theme.colors.primary};
    border-radius: 2px;
  }
`;

// TabæŒ‰é’®
const TabButton = styled.button<{ $active: boolean; $status: StepStatus }>`
  display: flex;
  align-items: center;
  gap: ${theme.spacing.xs};
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  background: ${props => props.$active ? theme.colors.bgSlight : theme.colors.bgDeep};
  border: 2px solid ${props => {
    if (props.$active) return theme.colors.primary;
    switch (props.$status) {
      case 'success': return theme.colors.success;
      case 'error': return theme.colors.error;
      case 'running': return theme.colors.primary;
      default: return theme.colors.border;
    }
  }};
  border-radius: ${theme.radius.sm};
  color: ${theme.colors.text};
  font-family: ${theme.typography.fontFamily};
  font-weight: bold;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s;
  white-space: nowrap;
  position: relative;
  
  ${props => props.$active && css`
    box-shadow: 0 0 15px ${theme.colors.primary}44;
  `}
  
  ${props => props.$status === 'running' && !props.$active && css`
    animation: ${pulseGlow} 2s ease-in-out infinite;
  `}
  
  &:hover {
    border-color: ${theme.colors.primary};
    transform: translateY(-2px);
  }
`;

// Tabæ­¥éª¤ç¼–å·
const TabStepNumber = styled.div<{ $status: StepStatus }>`
  width: 28px;
  height: 28px;
  background: ${props => {
    switch (props.$status) {
      case 'success': return theme.colors.success;
      case 'error': return theme.colors.error;
      case 'running': return theme.colors.primary;
      default: return theme.colors.border;
    }
  }};
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.85rem;
  flex-shrink: 0;
`;

// Tabå†…å®¹åŒºåŸŸ
const TabContent = styled.div`
  flex: 1;
  background: ${theme.colors.bgSlight};
  border: 2px solid ${theme.colors.border};
  border-radius: ${theme.radius.lg};
  padding: ${theme.spacing.lg};
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  
  &::-webkit-scrollbar {
    width: 6px;
  }
  
  &::-webkit-scrollbar-track {
    background: ${theme.colors.bgDeep};
    border-radius: 3px;
  }
  
  &::-webkit-scrollbar-thumb {
    background: ${theme.colors.primary};
    border-radius: 3px;
  }
`;

// å†…å®¹è¡Œ - å·¦å³å¸ƒå±€ï¼ˆå†…å®¹åœ¨å·¦ï¼ŒæŒ‰é’®åœ¨å³ï¼‰
const ContentRow = styled.div`
  display: grid;
  grid-template-columns: 1fr 180px;
  gap: ${theme.spacing.lg};
  align-items: start;
  
  @media (max-width: 1024px) {
    grid-template-columns: 1fr;
  }
`;

// ä¸»å†…å®¹åŒºï¼ˆå·¦ä¾§ï¼‰
const MainContent = styled.div`
  min-height: 0;
`;

// ä¾§è¾¹æ ï¼ˆå³ä¾§æŒ‰é’®åŒºï¼‰
const Sidebar = styled.div`
  display: flex;
  flex-direction: column;
  gap: ${theme.spacing.sm};
  position: sticky;
  top: 0;
  
  @media (max-width: 1024px) {
    flex-direction: row;
    flex-wrap: wrap;
    justify-content: center;
    position: static;
  }
`;

// æ­¥éª¤æ ‡é¢˜
const StepHeader = styled.div`
  margin-bottom: ${theme.spacing.md};
  flex-shrink: 0;
`;

const StepTitle = styled.h2`
  color: ${theme.colors.primary};
  font-size: 1.3rem;
  margin-bottom: ${theme.spacing.xs};
`;

const StepDescription = styled.p`
  color: ${theme.colors.textSecondary};
  font-size: 0.85rem;
`;

// æ­¥éª¤çŠ¶æ€å¾½ç« 
const StatusBadge = styled.div<{ $status: StepStatus }>`
  display: inline-flex;
  align-items: center;
  gap: ${theme.spacing.xs};
  padding: ${theme.spacing.xs} ${theme.spacing.sm};
  background: ${props => {
    switch (props.$status) {
      case 'success': return theme.colors.success + '22';
      case 'error': return theme.colors.error + '22';
      case 'running': return theme.colors.primary + '22';
      default: return theme.colors.border + '22';
    }
  }};
  border: 1px solid ${props => {
    switch (props.$status) {
      case 'success': return theme.colors.success;
      case 'error': return theme.colors.error;
      case 'running': return theme.colors.primary;
      default: return theme.colors.border;
    }
  }};
  border-radius: ${theme.radius.sm};
  color: ${props => {
    switch (props.$status) {
      case 'success': return theme.colors.success;
      case 'error': return theme.colors.error;
      case 'running': return theme.colors.primary;
      default: return theme.colors.textSecondary;
    }
  }};
  font-size: 0.85rem;
  font-weight: bold;
  margin-top: ${theme.spacing.xs};
`;

// è¡¨å•ç»„
const FormGroup = styled.div`
  margin-bottom: ${theme.spacing.md};
`;

// æ ‡ç­¾
const Label = styled.label`
  display: block;
  font-size: 0.85rem;
  color: ${theme.colors.textSecondary};
  margin-bottom: ${theme.spacing.xs};
  font-weight: 500;
`;

// è¾“å…¥æ¡†
const Input = styled.input`
  width: 100%;
  background: ${theme.colors.bgDeep};
  border: 1px solid ${theme.colors.border};
  border-radius: ${theme.radius.sm};
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  color: ${theme.colors.text};
  font-family: ${theme.typography.fontFamily};
  font-size: 0.95rem;
  
  &:focus {
    outline: none;
    border-color: ${theme.colors.primary};
    box-shadow: 0 0 0 2px ${theme.colors.primary}22;
  }
  
  &::placeholder {
    color: ${theme.colors.textSecondary};
    opacity: 0.6;
  }
`;

// æ–‡æœ¬åŸŸ
const TextArea = styled.textarea`
  width: 100%;
  min-height: 80px;
  max-height: 150px;
  background: ${theme.colors.bgDeep};
  border: 1px solid ${theme.colors.border};
  border-radius: ${theme.radius.sm};
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  color: ${theme.colors.text};
  font-family: ${theme.typography.fontFamily};
  font-size: 0.95rem;
  resize: vertical;
  line-height: 1.5;
  
  &:focus {
    outline: none;
    border-color: ${theme.colors.primary};
    box-shadow: 0 0 0 2px ${theme.colors.primary}22;
  }
  
  &::placeholder {
    color: ${theme.colors.textSecondary};
    opacity: 0.6;
  }
`;

// é€‰æ‹©æ¡†
const Select = styled.select`
  width: 100%;
  background: ${theme.colors.bgDeep};
  border: 1px solid ${theme.colors.border};
  border-radius: ${theme.radius.sm};
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  color: ${theme.colors.text};
  font-family: ${theme.typography.fontFamily};
  font-size: 0.95rem;
  cursor: pointer;
  
  &:focus {
    outline: none;
    border-color: ${theme.colors.primary};
    box-shadow: 0 0 0 2px ${theme.colors.primary}22;
  }
  
  option {
    background: ${theme.colors.bgDeep};
    color: ${theme.colors.text};
  }
`;

// ç»“æœæ˜¾ç¤ºæ¡†
const ResultBox = styled.div`
  background: ${theme.colors.bgDeep};
  border: 1px solid ${theme.colors.success};
  border-radius: ${theme.radius.sm};
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  margin-top: ${theme.spacing.md};
  max-height: 200px;
  overflow-y: auto;
  
  pre {
    margin: 0;
    color: ${theme.colors.success};
    font-size: 0.85rem;
    white-space: pre-wrap;
    word-break: break-all;
  }
`;

// é”™è¯¯æç¤º
const ErrorBox = styled.div`
  background: ${theme.colors.error}22;
  border: 1px solid ${theme.colors.error};
  border-radius: ${theme.radius.sm};
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  margin-top: ${theme.spacing.md};
  color: ${theme.colors.error};
  font-size: 0.9rem;
`;

// åŠ è½½åŠ¨ç”»
const LoadingSpinner = styled.div`
  width: 35px;
  height: 35px;
  border: 3px solid ${theme.colors.border};
  border-top: 3px solid ${theme.colors.primary};
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: ${theme.spacing.md} auto;
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
`;

// æ“ä½œæŒ‰é’®åŒºåŸŸ
const ActionButtons = styled.div`
  display: flex;
  gap: ${theme.spacing.sm};
  margin-top: ${theme.spacing.lg};
  padding-top: ${theme.spacing.md};
  border-top: 1px solid ${theme.colors.border};
  justify-content: center;
  flex-shrink: 0;
  flex-wrap: wrap;
`;

// æŒ‰é’® - ç»Ÿä¸€æ ·å¼
const Button = styled.button<{ $variant?: 'primary' | 'danger' }>`
  width: 100%;
  padding: ${theme.spacing.sm} ${theme.spacing.md};
  border: none;
  border-radius: ${theme.radius.sm};
  font-family: ${theme.typography.fontFamily};
  font-weight: bold;
  cursor: pointer;
  transition: all 0.3s;
  font-size: 0.85rem;
  background: linear-gradient(90deg, ${theme.colors.primary}, ${theme.colors.secondary});
  color: ${theme.colors.white};
  
  ${props => props.$variant === 'danger' && css`
    background: ${theme.colors.error};
    &:hover:not(:disabled) {
      background: ${theme.colors.error}dd;
    }
  `}
  
  &:hover:not(:disabled) {
    box-shadow: ${theme.shadows.glow};
    transform: translateY(-2px);
  }
  
  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  @media (max-width: 1024px) {
    width: auto;
    min-width: 140px;
  }
`;

// æç¤ºæ¡† - æ›´ç´§å‡‘
const HintBox = styled.div`
  background: ${theme.colors.primary}11;
  border-left: 3px solid ${theme.colors.primary};
  border-radius: ${theme.radius.sm};
  padding: ${theme.spacing.xs} ${theme.spacing.sm};
  margin-bottom: ${theme.spacing.sm};
  color: ${theme.colors.textSecondary};
  line-height: 1.4;
  font-size: 0.8rem;
  
  strong {
    color: ${theme.colors.primary};
  }
`;

// QRæ‰«ç å®¹å™¨ï¼ˆå±…ä¸­ï¼‰
const QRScannerWrapper = styled.div`
  display: flex;
  justify-content: center;
  margin: ${theme.spacing.md} 0;
`;

function WorkflowPage() {
  const router = useRouter();
  const [currentTab, setCurrentTab] = useState<WorkflowStep>('parse_video');
  const [workflowSteps, setWorkflowSteps] = useState<WorkflowStepInfo[]>(
    WORKFLOW_STEPS.map(step => ({ ...step }))
  );
  const [autoMode, setAutoMode] = useState<'manual' | 'auto-synthesis' | 'auto-publish'>('manual');
  
  // æ‰«ç çŠ¶æ€ï¼ˆå…¨å±€ï¼Œåœ¨å‘å¸ƒæ­¥éª¤ä½¿ç”¨ï¼‰
  const [douyinScanned, setDouyinScanned] = useState(false);
  const [douyinUserInfo, setDouyinUserInfo] = useState<DouyinUserInfo | null>(null);
  
  // å„æ­¥éª¤çš„è¡¨å•æ•°æ®
  const [douyinUrl, setDouyinUrl] = useState('');
  const [rewriteParams, setRewriteParams] = useState<RewriteParams>({
    content: '',
    styles: 'ä¸“ä¸š',
    tone: 'å‹å¥½',
    extraInstructions: ''
  });
  const [audioParams, setAudioParams] = useState<SynthesizeAudioParams>({
    audioPath: '',
    content: '',
    emotionText: 'å¹³é™'
  });
  const [videoParams, setVideoParams] = useState<SynthesizeVideoParams>({
    audioPath: '',
    videoPath: '',
    pixelType: PixelType.RATIO_9_16
  });
  const [publishParams, setPublishParams] = useState<PublishVideoParams>({
    videoPath: '',
    title: '',
    description: ''
  });

  // æ›´æ–°æ­¥éª¤çŠ¶æ€
  const updateStepStatus = (stepId: WorkflowStep, updates: Partial<WorkflowStepInfo>) => {
    setWorkflowSteps(prev => prev.map(step => 
      step.id === stepId ? { ...step, ...updates } : step
    ));
  };

  // è·å–å½“å‰æ­¥éª¤ä¿¡æ¯
  const getCurrentStep = () => {
    return workflowSteps.find(step => step.id === currentTab);
  };

  // è·å–å½“å‰æ­¥éª¤ç´¢å¼•
  const getCurrentStepIndex = () => {
    return workflowSteps.findIndex(step => step.id === currentTab);
  };

  // è‡ªåŠ¨æ‰§è¡Œä¸‹ä¸€æ­¥
  const autoExecuteNext = () => {
    const currentIndex = getCurrentStepIndex();
    if (currentIndex < workflowSteps.length - 1) {
      const nextStep = workflowSteps[currentIndex + 1];
      
      // å¦‚æœæ˜¯ä¸€é”®åˆæˆæ¨¡å¼ä¸”åˆ°äº†å‘å¸ƒæ­¥éª¤ï¼Œåˆ™åœæ­¢
      if (autoMode === 'auto-synthesis' && nextStep.id === 'publish_video') {
        setAutoMode('manual');
        return;
      }
      
      // åˆ‡æ¢åˆ°ä¸‹ä¸€ä¸ªtabå¹¶æ‰§è¡Œ
      setTimeout(() => {
        setCurrentTab(nextStep.id);
        executeStep(nextStep.id);
      }, 1000);
    } else {
      setAutoMode('manual');
    }
  };

  // æ‰§è¡Œæ­¥éª¤
  const executeStep = async (stepId: WorkflowStep) => {
    updateStepStatus(stepId, { status: 'running', startTime: Date.now() });

    try {
      switch (stepId) {
        case 'parse_video':
          if (!douyinUrl) {
            throw new Error('è¯·è¾“å…¥æŠ–éŸ³è§†é¢‘é“¾æ¥');
          }
          const parseRes = await parseVideoContent(douyinUrl);
          const parsedContent = parseRes.data.data;
          updateStepStatus(stepId, {
            status: 'success',
            result: { parsedContent },
            endTime: Date.now()
          });
          setRewriteParams(prev => ({ ...prev, content: parsedContent }));
          if (autoMode !== 'manual') {
            autoExecuteNext();
          }
          break;

        case 'rewrite_content':
          const rewriteRes = await rewriteContent(rewriteParams);
          const rewrittenContent = rewriteRes.data.data;
          updateStepStatus(stepId, {
            status: 'success',
            result: { rewrittenContent },
            endTime: Date.now()
          });
          setAudioParams(prev => ({ ...prev, content: rewrittenContent }));
          if (autoMode !== 'manual') {
            autoExecuteNext();
          }
          break;

        case 'synthesize_audio':
          const audioRes = await synthesizeAudio(audioParams);
          const audioUrl = audioRes.data.data;
          updateStepStatus(stepId, {
            status: 'success',
            result: { audioUrl },
            endTime: Date.now()
          });
          setVideoParams(prev => ({ ...prev, audioPath: audioUrl }));
          if (autoMode !== 'manual') {
            autoExecuteNext();
          }
          break;

        case 'synthesize_video':
          const videoRes = await synthesizeVideo(videoParams);
          const videoUrl = videoRes.data.data;
          updateStepStatus(stepId, {
            status: 'success',
            result: { videoUrl },
            endTime: Date.now()
          });
          setPublishParams(prev => ({ ...prev, videoPath: videoUrl }));
          if (autoMode !== 'manual') {
            autoExecuteNext();
          }
          break;

        case 'publish_video':
          if (!douyinScanned) {
            throw new Error('è¯·å…ˆå®ŒæˆæŠ–éŸ³æ‰«ç æˆæƒ');
          }
          await publishVideo(publishParams);
          updateStepStatus(stepId, {
            status: 'success',
            result: { publishStatus: true },
            endTime: Date.now()
          });
          setAutoMode('manual');
          break;
      }
    } catch (error: any) {
      updateStepStatus(stepId, {
        status: 'error',
        error: error.message || 'æ“ä½œå¤±è´¥',
        endTime: Date.now()
      });
      setAutoMode('manual');
    }
  };

  // æ‰«ç æˆåŠŸå›è°ƒ
  const handleDouyinScanSuccess = (userInfo: DouyinUserInfo) => {
    setDouyinScanned(true);
    setDouyinUserInfo(userInfo);
  };

  // ä¸€é”®åˆæˆï¼ˆåˆ°è§†é¢‘åˆæˆä¸ºæ­¢ï¼‰
  const handleAutoSynthesis = () => {
    setAutoMode('auto-synthesis');
    executeStep(currentTab);
  };

  // ä¸€é”®å‘å¸ƒï¼ˆè‡ªåŠ¨æ‰§è¡Œæ‰€æœ‰æ­¥éª¤ï¼‰
  const handleAutoPublish = () => {
    setAutoMode('auto-publish');
    executeStep(currentTab);
  };

  // è·å–æ­¥éª¤çŠ¶æ€æ–‡æœ¬
  const getStepStatusText = (status: StepStatus) => {
    switch (status) {
      case 'pending': return 'å¾…æ‰§è¡Œ';
      case 'running': return 'æ‰§è¡Œä¸­...';
      case 'success': return 'âœ“ å·²å®Œæˆ';
      case 'error': return 'âœ— æ‰§è¡Œå¤±è´¥';
      case 'skipped': return 'å·²è·³è¿‡';
      default: return '';
    }
  };

  // æ¸²æŸ“å½“å‰Tabçš„å†…å®¹
  const renderTabContent = () => {
    const step = getCurrentStep();
    if (!step) return null;

    switch (step.id) {

      case 'parse_video':
        return (
          <>
            <HintBox>
              <strong>ğŸ’¡ æ“ä½œæç¤ºï¼š</strong> è¾“å…¥æŠ–éŸ³è§†é¢‘åˆ†äº«é“¾æ¥ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨è§£æè§†é¢‘ä¸­çš„æ–‡æ¡ˆå†…å®¹ã€‚
            </HintBox>
            <FormGroup>
              <Label>æŠ–éŸ³è§†é¢‘é“¾æ¥</Label>
              <Input
                type="text"
                placeholder="https://v.douyin.com/..."
                value={douyinUrl}
                onChange={(e) => setDouyinUrl(e.target.value)}
                disabled={step.status === 'running'}
              />
            </FormGroup>
            {step.status === 'running' && <LoadingSpinner />}
            {step.result?.parsedContent && (
              <ResultBox>
                <Label>è§£æç»“æœ</Label>
                <pre>{step.result.parsedContent}</pre>
              </ResultBox>
            )}
            {step.error && <ErrorBox>âŒ {step.error}</ErrorBox>}
          </>
        );

      case 'rewrite_content':
        return (
          <>
            <HintBox>
              <strong>ğŸ’¡ æ“ä½œæç¤ºï¼š</strong> æ ¹æ®åŸå§‹æ–‡æ¡ˆï¼Œè®¾ç½®æœŸæœ›çš„é£æ ¼å’Œè¯­æ°”ï¼ŒAIå°†æ™ºèƒ½é‡å†™æ–‡æ¡ˆå†…å®¹ã€‚
            </HintBox>
            <FormGroup>
              <Label>åŸå§‹æ–‡æ¡ˆ</Label>
              <TextArea
                value={rewriteParams.content}
                onChange={(e) => setRewriteParams(prev => ({ ...prev, content: e.target.value }))}
                placeholder="è¾“å…¥æˆ–ä»ä¸Šä¸€æ­¥è‡ªåŠ¨è·å–æ–‡æ¡ˆ"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>é£æ ¼</Label>
              <Input
                type="text"
                value={rewriteParams.styles}
                onChange={(e) => setRewriteParams(prev => ({ ...prev, styles: e.target.value }))}
                placeholder="ä¾‹å¦‚ï¼šä¸“ä¸šã€è½»æ¾ã€å¹½é»˜"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>è¯­æ°”</Label>
              <Input
                type="text"
                value={rewriteParams.tone}
                onChange={(e) => setRewriteParams(prev => ({ ...prev, tone: e.target.value }))}
                placeholder="ä¾‹å¦‚ï¼šå‹å¥½ã€æ­£å¼ã€æ´»æ³¼"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>é™„åŠ è¦æ±‚ï¼ˆå¯é€‰ï¼‰</Label>
              <TextArea
                value={rewriteParams.extraInstructions}
                onChange={(e) => setRewriteParams(prev => ({ ...prev, extraInstructions: e.target.value }))}
                placeholder="ä¾‹å¦‚ï¼šéœ€è¦åŒ…å«ç‰¹å®šå…³é”®è¯ã€æ§åˆ¶å­—æ•°ç­‰"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            {step.status === 'running' && <LoadingSpinner />}
            {step.result?.rewrittenContent && (
              <ResultBox>
                <Label>é‡å†™ç»“æœ</Label>
                <pre>{step.result.rewrittenContent}</pre>
              </ResultBox>
            )}
            {step.error && <ErrorBox>âŒ {step.error}</ErrorBox>}
          </>
        );

      case 'synthesize_audio':
        return (
          <>
            <HintBox>
              <strong>ğŸ’¡ æ“ä½œæç¤ºï¼š</strong> é€‰æ‹©å‚è€ƒéŸ³è‰²ï¼Œç³»ç»Ÿå°†ä½¿ç”¨AIè¯­éŸ³åˆæˆæŠ€æœ¯ç”ŸæˆéŸ³é¢‘æ–‡ä»¶ã€‚
            </HintBox>
            <FormGroup>
              <Label>å‚è€ƒéŸ³è‰²è·¯å¾„</Label>
              <Input
                type="text"
                value={audioParams.audioPath}
                onChange={(e) => setAudioParams(prev => ({ ...prev, audioPath: e.target.value }))}
                placeholder="éŸ³é¢‘æ–‡ä»¶è·¯å¾„æˆ–URL"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>æ–‡æœ¬å†…å®¹</Label>
              <TextArea
                value={audioParams.content}
                onChange={(e) => setAudioParams(prev => ({ ...prev, content: e.target.value }))}
                placeholder="è¾“å…¥æˆ–ä»ä¸Šä¸€æ­¥è‡ªåŠ¨è·å–æ–‡æ¡ˆ"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>æƒ…ç»ªæè¿°</Label>
              <Input
                type="text"
                value={audioParams.emotionText}
                onChange={(e) => setAudioParams(prev => ({ ...prev, emotionText: e.target.value }))}
                placeholder="ä¾‹å¦‚ï¼šå¹³é™ã€æ¿€åŠ¨ã€æ¸©æŸ”"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            {step.status === 'running' && <LoadingSpinner />}
            {step.result?.audioUrl && (
              <ResultBox>
                <Label>éŸ³é¢‘URL</Label>
                <pre>{step.result.audioUrl}</pre>
                <audio controls src={step.result.audioUrl} style={{ width: '100%', marginTop: theme.spacing.md }} />
              </ResultBox>
            )}
            {step.error && <ErrorBox>âŒ {step.error}</ErrorBox>}
          </>
        );

      case 'synthesize_video':
        return (
          <>
            <HintBox>
              <strong>ğŸ’¡ æ“ä½œæç¤ºï¼š</strong> ä¸Šä¼ è§†é¢‘ç´ æï¼Œé€‰æ‹©ç”»é¢æ¯”ä¾‹ï¼Œç³»ç»Ÿå°†è‡ªåŠ¨åˆæˆéŸ³é¢‘å’Œè§†é¢‘ã€‚
            </HintBox>
            <FormGroup>
              <Label>éŸ³é¢‘è·¯å¾„</Label>
              <Input
                type="text"
                value={videoParams.audioPath}
                onChange={(e) => setVideoParams(prev => ({ ...prev, audioPath: e.target.value }))}
                placeholder="éŸ³é¢‘æ–‡ä»¶è·¯å¾„æˆ–URLï¼ˆè‡ªåŠ¨ä»ä¸Šä¸€æ­¥è·å–ï¼‰"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>è§†é¢‘ç´ æè·¯å¾„</Label>
              <Input
                type="text"
                value={videoParams.videoPath}
                onChange={(e) => setVideoParams(prev => ({ ...prev, videoPath: e.target.value }))}
                placeholder="è§†é¢‘æ–‡ä»¶è·¯å¾„æˆ–URL"
                disabled={step.status === 'running'}
              />
            </FormGroup>
            <FormGroup>
              <Label>ç”»é¢æ¯”ä¾‹</Label>
              <Select
                value={videoParams.pixelType}
                onChange={(e) => setVideoParams(prev => ({ ...prev, pixelType: e.target.value as PixelType }))}
                disabled={step.status === 'running'}
              >
                <option value={PixelType.RATIO_9_16}>9:16 (ç«–å± - æŠ–éŸ³æ¨è)</option>
                <option value={PixelType.RATIO_16_9}>16:9 (æ¨ªå±)</option>
                <option value={PixelType.RATIO_1_1}>1:1 (æ­£æ–¹å½¢)</option>
              </Select>
            </FormGroup>
            {step.status === 'running' && <LoadingSpinner />}
            {step.result?.videoUrl && (
              <ResultBox>
                <Label>è§†é¢‘URL</Label>
                <pre>{step.result.videoUrl}</pre>
                <video controls src={step.result.videoUrl} style={{ width: '100%', maxHeight: '400px', marginTop: theme.spacing.md }} />
              </ResultBox>
            )}
            {step.error && <ErrorBox>âŒ {step.error}</ErrorBox>}
          </>
        );

      case 'publish_video':
        return (
          <>
            <HintBox>
              <strong>ğŸ’¡ æ“ä½œæç¤ºï¼š</strong> å…ˆå®ŒæˆæŠ–éŸ³æ‰«ç æˆæƒï¼Œç„¶åè®¾ç½®è§†é¢‘æ ‡é¢˜å’Œæè¿°ï¼ˆå¯é€‰ï¼‰ï¼Œæœ€åç‚¹å‡»å‘å¸ƒæŒ‰é’®å°†è§†é¢‘ä¸Šä¼ åˆ°æŠ–éŸ³å¹³å°ã€‚
            </HintBox>
            
            {/* æ‰«ç åŒºåŸŸ */}
            <FormGroup>
              <Label>æŠ–éŸ³è´¦å·æˆæƒ</Label>
              {!douyinScanned ? (
                <QRScannerWrapper>
                  <DouyinQRScanner
                    onScanSuccess={handleDouyinScanSuccess}
                    onScanStatusChange={setDouyinScanned}
                  />
                </QRScannerWrapper>
              ) : (
                <ResultBox>
                  <Label>å·²æˆæƒè´¦å·</Label>
                  <pre>âœ… {douyinUserInfo?.nickname}</pre>
                </ResultBox>
              )}
            </FormGroup>
            
            {/* å‘å¸ƒè¡¨å• */}
            <FormGroup>
              <Label>è§†é¢‘è·¯å¾„</Label>
              <Input
                type="text"
                value={publishParams.videoPath}
                onChange={(e) => setPublishParams(prev => ({ ...prev, videoPath: e.target.value }))}
                placeholder="å¾…å‘å¸ƒè§†é¢‘è·¯å¾„ï¼ˆè‡ªåŠ¨ä»ä¸Šä¸€æ­¥è·å–ï¼‰"
                disabled={step.status === 'running' || !douyinScanned}
              />
            </FormGroup>
            <FormGroup>
              <Label>æ ‡é¢˜ï¼ˆå¯é€‰ï¼‰</Label>
              <Input
                type="text"
                value={publishParams.title || ''}
                onChange={(e) => setPublishParams(prev => ({ ...prev, title: e.target.value }))}
                placeholder="è§†é¢‘æ ‡é¢˜"
                disabled={step.status === 'running' || !douyinScanned}
              />
            </FormGroup>
            <FormGroup>
              <Label>æè¿°ï¼ˆå¯é€‰ï¼‰</Label>
              <TextArea
                value={publishParams.description || ''}
                onChange={(e) => setPublishParams(prev => ({ ...prev, description: e.target.value }))}
                placeholder="è§†é¢‘æè¿°"
                disabled={step.status === 'running' || !douyinScanned}
              />
            </FormGroup>
            {step.status === 'running' && <LoadingSpinner />}
            {step.result?.publishStatus && (
              <ResultBox>
                <Label>å‘å¸ƒçŠ¶æ€</Label>
                <pre>âœ… å‘å¸ƒæˆåŠŸï¼è§†é¢‘å·²ä¸Šä¼ åˆ°æŠ–éŸ³å¹³å°</pre>
              </ResultBox>
            )}
            {step.error && <ErrorBox>âŒ {step.error}</ErrorBox>}
          </>
        );

      default:
        return null;
    }
  };

  const currentStep = getCurrentStep();

  return (
    <PageContainer>
      <GridBackground />
      <Container>
        <Title>æ™ºèƒ½è§†é¢‘åˆ›ä½œå·¥ä½œæµ</Title>
        
        {/* Tabå¯¼èˆª */}
        <TabNav>
          {workflowSteps.map((step, index) => (
            <TabButton
              key={step.id}
              $active={currentTab === step.id}
              $status={step.status}
              onClick={() => setCurrentTab(step.id)}
            >
              <TabStepNumber $status={step.status}>
                {step.status === 'success' ? 'âœ“' : index + 1}
              </TabStepNumber>
              <div>
                <div>{step.name}</div>
                {currentTab !== step.id && (
                  <div style={{ fontSize: '0.75rem', opacity: 0.7 }}>
                    {getStepStatusText(step.status)}
                  </div>
                )}
              </div>
            </TabButton>
          ))}
        </TabNav>
        
        {/* Tabå†…å®¹ */}
        <TabContent>
          {currentStep && (
            <>
              <StepHeader>
                <StepTitle>{currentStep.name}</StepTitle>
                <StepDescription>{currentStep.description}</StepDescription>
                <StatusBadge $status={currentStep.status}>
                  {getStepStatusText(currentStep.status)}
                </StatusBadge>
              </StepHeader>
              
              <ContentRow>
                {/* å·¦ä¾§ï¼šå†…å®¹åŒº */}
                <MainContent>
                  {renderTabContent()}
                </MainContent>
                
                {/* å³ä¾§ï¼šæŒ‰é’®åŒº */}
                <Sidebar>
                  <Button
                    onClick={() => executeStep(currentStep.id)}
                    disabled={currentStep.status === 'running' || autoMode !== 'manual'}
                  >
                    {currentStep.status === 'running' ? 'æ‰§è¡Œä¸­...' : 'æ‰§è¡Œæ­¤æ­¥éª¤'}
                  </Button>
                  
                  <Button
                    onClick={handleAutoSynthesis}
                    disabled={autoMode !== 'manual' || currentStep.status === 'running'}
                  >
                    {autoMode === 'auto-synthesis' ? 'åˆæˆä¸­...' : 'ä¸€é”®åˆæˆ'}
                  </Button>
                  
                  <Button
                    onClick={handleAutoPublish}
                    disabled={autoMode !== 'manual' || currentStep.status === 'running'}
                  >
                    {autoMode === 'auto-publish' ? 'å‘å¸ƒä¸­...' : 'ä¸€é”®å‘å¸ƒ'}
                  </Button>
                  
                  {autoMode !== 'manual' && (
                    <Button
                      $variant="danger"
                      onClick={() => setAutoMode('manual')}
                    >
                      åœæ­¢æ‰§è¡Œ
                    </Button>
                  )}
                  
                  {currentStep.status === 'error' && (
                    <Button
                      $variant="danger"
                      onClick={() => updateStepStatus(currentStep.id, { status: 'pending', error: undefined })}
                    >
                      é‡ç½®
                    </Button>
                  )}
                </Sidebar>
              </ContentRow>
            </>
          )}
        </TabContent>
      </Container>
    </PageContainer>
  );
}

export default function WorkflowPageWithAuth() {
  return (
    <AuthGuard>
      <WorkflowPage />
    </AuthGuard>
  );
}